using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using Microsoft.CodeAnalysis.Text;

namespace WinUI.System.Icons.Generator;

using global::System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;

[Generator]
public class IconsGenerator : ISourceGenerator
{
    public string GetCallerLocation([CallerFilePath] string filePath = "")
    {
        return filePath;
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // Find the main method
        var mainMethod = context.Compilation.GetEntryPoint(context.CancellationToken);
        var svgReg = new Regex(@"ic_fluent_(?<name>\w+)_(?<size>\d+)_(?<type>regular|filled).svg");

        // Build up the source code
        var dir = Path.Combine(Directory.GetParent(new FileInfo(GetCallerLocation())
            .DirectoryName).FullName, "vendor", "fluentui-system-icons", "assets");

        // Build the source
        var fluentSymbolEnumBuilder = new StringBuilder();
        var allFluentIconsBuilder = new StringBuilder();
        var appendedIcons = new List<string>();

        // Prepare the json file
        allFluentIconsBuilder.AppendLine("{");

        foreach (var (path, match) in Directory.EnumerateDirectories(dir, @"*", SearchOption.TopDirectoryOnly)
                     .Select(folder => new { folder, svgFolder = Path.Combine(folder, "SVG") })
                     .SelectMany(t => Directory.EnumerateFiles(t.svgFolder, @"*", SearchOption.AllDirectories),
                         (t, path) => new { t, path })
                     .Select(t => new { t, match = svgReg.Match(t.path) })
                     .Select(t => (t.t.path, t.match))
                     .Where(t => t.match.Success))
        {
            // Extrapolate the symbol name from the file path
            var file = path.Substring(dir.Length + 1); // Also remove the slash
            Console.WriteLine(file);
            var isFilled = match.Groups["type"].Value == "filled";
            var name = file.Split('\\')[0].Replace(" ", "") + match.Groups["size"] + (isFilled ? "Filled" : "");

            // Load the path data into a string
            var svg = new XmlDocument();
            svg.Load(path);

            // Create namespace manager
            var xmlnsManager = new XmlNamespaceManager(svg.NameTable);
            xmlnsManager.AddNamespace("svg", "http://www.w3.org/2000/svg");

            // Select all SVG path elements
            var list = svg.LastChild?.SelectNodes("//svg:path", xmlnsManager);
            var xamlPathData = list?.Cast<XmlNode>().Aggregate("",
                (current, pathElem) => current + pathElem.Attributes?["d"]?.Value + " ");

            // Prevent multiple additions
            if (appendedIcons.Contains(name)) continue;

            // Generate the C# source code
            fluentSymbolEnumBuilder.AppendLine($"        {name},");
            allFluentIconsBuilder.AppendLine($"\t\"{name}\": \"{xamlPathData}\",");
            appendedIcons.Add(name); // Prevent multiple additions
        }

        // Prepare the source
        var source = new StringBuilder(@"// <auto-generated/>
using System.Collections.Generic;

namespace WinUI.System.Icons
{
    /// <summary>
    /// An enum listing all available Fluent System Icon symbols
    /// </summary>
    public enum FluentSymbol 
    {
[{fluentSymbolEnumBuilder}]
    }
}");

        // Add the source code to the compilation
        context.AddSource("FluentSymbolIcon.g.cs", source
            .Replace("[{fluentSymbolEnumBuilder}]", fluentSymbolEnumBuilder.ToString()).ToString());

        File.WriteAllText(Path.Combine(Directory.GetParent(new FileInfo(GetCallerLocation())
                .DirectoryName).FullName, "WinUI.System.Icons", "Assets", "FluentSymbolIcons.json"),
            allFluentIconsBuilder.ToString().TrimEnd('\r', '\n', ',') + "\n}");
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization required for this one
    }
}